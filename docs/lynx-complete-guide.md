# Lynx Framework by ByteDance: Complete Developer Guide

## Overview

Lynx is ByteDance's open-source cross-platform framework that empowers developers to build high-performance native mobile and web applications using familiar web technologies like JavaScript, TypeScript, CSS, and React. Designed to deliver truly native performance while maintaining development simplicity, Lynx bridges the gap between web development skills and native app creation.

## Key Features

### Performance-First Architecture
- **Dual-Threaded System**: Separates UI rendering (main thread) from business logic (background thread)
- **Instant First-Frame Rendering (IFR)**: Eliminates loading screens for snappy user experiences
- **Main Thread Scripting (MTS)**: Enables smooth animations and gesture handling directly on the main thread
- **PrimJS Engine**: Optimized JavaScript runtime for faster startup and reduced memory usage

### Web-Native Development
- **Full CSS Support**: Including animations, selectors, variables, and modern visual effects
- **React Compatibility**: Built-in ReactLynx framework with familiar React patterns
- **Framework Agnostic**: Supports multiple frontend frameworks (Vue, React, etc.)
- **Web Standards**: Leverages existing web development knowledge and libraries

### Cross-Platform Excellence
- **Write Once, Render Anywhere**: Single codebase for Android, iOS, and Web
- **Native Rendering**: Platform-specific UI primitives for authentic native experiences
- **Pixel-Perfect Consistency**: Custom renderer ensures identical UI across platforms

## Getting Started

### System Requirements
- Node.js 18 or later
- macOS recommended for development (Windows and Linux support available)
- iOS 10+ / Android 5.0 (API 21)+ for target applications

### Project Setup

#### 1. Create New Project
```bash
npm create rspeedy@latest
```

Choose your project configuration:
- Project name
- Language: TypeScript (recommended) or JavaScript
- Additional tools: Biome, ESLint, etc.

#### 2. Install Dependencies
```bash
cd <project-name>
npm install
```

#### 3. Start Development Server
```bash
npm run dev
```

### Lynx Explorer Setup

Download Lynx Explorer for testing:
- **iOS**: LynxExplorer for iOS Simulator or device
- **Android**: LynxExplorer APK for Android devices/emulators

Scan the QR code generated by the development server or enter the bundle URL manually in Lynx Explorer.

## Core Framework Components

### ReactLynx Framework

ReactLynx is the official React implementation for Lynx, providing familiar React patterns with native performance optimizations.

#### Key Differences from Web React

**Import Changes**:
```javascript
// Before (Web React)
import { useState } from 'react';

// After (ReactLynx)  
import { useState } from '@lynx-js/react';
```

**Element Mapping**:
```javascript
// Web HTML elements
<div className="container">
  <p>Hello World</p>
  <img src="image.jpg" />
</div>

// Lynx native elements
<view className="container">
  <text>Hello World</text>
  <image src="image.jpg" />
</view>
```

### Built-in Elements

Lynx provides a comprehensive set of native elements that map to platform-specific UI components:

#### Core Elements

**`<view>`**: The foundational container element
- **Purpose**: Basic layout container, equivalent to `div` on web
- **Platform mapping**: 
  - Android: `ViewGroup`
  - iOS: `UIView`
  - Web: Non-scrollable `<div>`

```javascript
<view style="padding:10px;background:gray;">
  <text>Content goes here</text>
</view>
```

**`<text>`**: Text display element
- **Purpose**: Display text content
- **Platform mapping**:
  - Android: `TextView`
  - iOS: `UITextView`
  - Web: `<p>`

```javascript
<text style="color:blue;font-size:16px;">Hello Lynx</text>
```

**`<image>`**: Image display element
- **Purpose**: Display images from local or remote sources
- **Platform mapping**:
  - Android: `ImageView`
  - iOS: `UIImageView`
  - Web: `<img>`

```javascript
<image 
  auto-size 
  style="width:100px;height:100px;" 
  src="./assets/logo.png" 
/>
```

#### Advanced Elements

**`<scroll-view>`**: Basic scrollable container
- **Purpose**: Simple scrollable content area
- **Platform mapping**:
  - Android: `ScrollView`
  - iOS: `UIScrollView`
  - Web: `<div>` with `overflow:scroll`

```javascript
<scroll-view style="height:200px;">
  <view>Scrollable content</view>
</scroll-view>
```

**`<list>`**: High-performance scrollable list
- **Purpose**: Optimized for large datasets with recycling and lazy loading
- **Platform mapping**:
  - Android: `RecyclerView`
  - iOS: `UICollectionView`
  - Web: Custom implementation

```javascript
<list 
  list-type="waterfall" 
  column-count={2}
  scroll-orientation="vertical"
  bindscroll={handleScroll}
>
  {data.map((item, index) => (
    <list-item 
      item-key={`item-${index}`} 
      key={`item-${index}`}
    >
      <YourComponent data={item} />
    </list-item>
  ))}
</list>
```

**Key `<list>` Attributes**:
- `list-type`: `'single' | 'flow' | 'waterfall'`
- `span-count`: Number of columns/rows
- `scroll-orientation`: `'vertical' | 'horizontal'`
- `enable-scroll`: Enable/disable scrolling
- `lower-threshold-item-count`: Trigger point for infinite scroll

**`<page>`**: Root page container
- **Purpose**: Root node of a page, usually auto-generated
- **Platform mapping**:
  - Android: `ViewRootImpl` of a page
  - iOS: `UIViewController.view`
  - Web: Non-resizable `<body>`

## Styling and Layout

### CSS Support

Lynx provides comprehensive CSS support with web-like styling capabilities:

#### Standard CSS Properties
```css
.container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 20px;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
```

#### Lynx-Specific Properties
Properties prefixed with `-x-` provide Lynx-specific functionality:

```css
.text-selection {
  -x-handle-color: blue; /* Text selection handle color */
}

.special-layout {
  display: -x-linear; /* Lynx linear layout */
  -x-linear-orientation: horizontal;
}
```

#### Layout Systems

**Flexible Box Layout (Flexbox)**:
```css
.flex-container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
}

.flex-item {
  flex: 1;
  flex-grow: 2;
  flex-shrink: 0;
}
```

**Linear Layout (Lynx Default)**:
```css
.linear-container {
  display: linear; /* or -x-linear */
  linear-orientation: vertical;
}
```

**Grid Layout** (subset support):
```css
.grid-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-gap: 10px;
}
```

**Relative Layout**:
```css
.relative-container {
  display: relative;
  position: relative;
}
```

### Styling Methods

#### 1. Inline Styles (React-style)
```javascript
<view style={{
  flexDirection: "column",
  marginTop: "50%",
  width: "150px",
  height: "150px",
  backgroundColor: "red"
}}>
  Content
</view>
```

#### 2. CSS Classes
```javascript
<view className="container">
  <text className="title">Hello World</text>
</view>
```

#### 3. CSS Modules
```javascript
import styles from './Component.module.css';

<view className={styles.container}>
  <text className={styles.title}>Styled Text</text>
</view>
```

#### 4. Global Styles
```javascript
// Import global CSS
import './index.css';
```

#### 5. Sass/SCSS Support
```scss
.container {
  background: red;
  
  &-header {
    border-radius: 30px;
  }
  
  .nested {
    color: blue;
  }
}
```

### CSS Variables and Themes
```css
:root {
  --primary-color: #3498db;
  --secondary-color: #2ecc71;
  --spacing: 16px;
}

.themed-component {
  background: var(--primary-color);
  padding: var(--spacing);
}
```

## Animations and Transitions

### CSS Transitions
```css
.animated-element {
  transition: all 0.3s ease-in-out;
  background: blue;
}

.animated-element:hover {
  background: red;
  transform: scale(1.1);
}
```

### Keyframe Animations
```css
@keyframes slideIn {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.slide-animation {
  animation: slideIn 0.5s ease-out;
}
```

### Complex Animation Example
```css
.like-animation {
  position: relative;
}

.circle {
  position: absolute;
  width: 20px;
  height: 20px;
  background: rgba(255, 0, 0, 0.3);
  border-radius: 50%;
  animation: expand 0.6s ease-out;
}

@keyframes expand {
  0% {
    transform: scale(0);
    opacity: 1;
  }
  100% {
    transform: scale(3);
    opacity: 0;
  }
}
```

## Event Handling

Lynx uses a unique dual-threaded event system for optimal performance.

### Event Binding Syntax

#### Background Thread Events (Default)
```javascript
const handleTap = (event) => {
  console.log('Tapped!', event.detail);
};

<view bindtap={handleTap}>Tap me</view>
```

#### Main Thread Events (MTS)
For smooth animations and immediate responses:

```javascript
const handleTapMTS = (event) => {
  'main thread'; // Required directive
  
  // Direct DOM manipulation possible
  event.currentTarget.setStyleProperty('background', 'red');
};

<view main-thread:bindtap={handleTapMTS}>Immediate response</view>
```

### Common Event Types

#### Touch Events
```javascript
<view 
  bindtouchstart={handleTouchStart}
  bindtouchmove={handleTouchMove}
  bindtouchend={handleTouchEnd}
>
  Touch area
</view>
```

#### Scroll Events
```javascript
const handleScroll = (event) => {
  const { scrollTop, scrollLeft, scrollHeight } = event.detail;
  console.log('Scroll position:', scrollTop);
};

<scroll-view bindscroll={handleScroll}>
  Scrollable content
</scroll-view>
```

#### List Events
```javascript
const handleScrollToLower = () => {
  // Load more data
  loadMoreItems();
};

<list 
  bindscrolltolower={handleScrollToLower}
  lower-threshold-item-count={3}
>
  {items.map(renderItem)}
</list>
```

### Event Propagation

#### Bind vs Catch
- `bind*`: Event bubbles up the element tree
- `catch*`: Event stops at this element (like `stopPropagation`)

```javascript
<view bindtap={parentHandler}>
  <view catchtap={childHandler}>
    Child captures event
  </view>
</view>
```

## Development Tools and Debugging

### Lynx DevTool

The Lynx DevTool is an Electron-based debugging application that provides comprehensive debugging capabilities.

#### Installation and Setup
1. Download Lynx DevTool from the official website
2. Install on your development machine
3. Enable debugging in Lynx Explorer settings
4. Connect device via USB cable

#### Features
- **Element Inspector**: Examine element tree and properties
- **Performance Monitor**: Track performance metrics and bottlenecks
- **Network Inspector**: Monitor API calls and resource loading
- **Console Debugging**: View logs and errors
- **Layout Debugging**: Visualize layout and styling issues

#### Usage
```javascript
// Enable debugging in your app
console.log('Debug message');
console.error('Error occurred');

// Performance measuring
console.time('operation');
// ... your code
console.timeEnd('operation');
```

### Hot Reloading

Lynx supports hot reloading for rapid development:

```javascript
// Changes to App.tsx are automatically reflected
const App = () => {
  return (
    <view className="app">
      <text>Hello Lynx - changes appear instantly!</text>
    </view>
  );
};
```

## Advanced Features

### Main Thread Scripting (MTS)

Main Thread Scripting allows critical code to run on the UI thread for immediate response.

#### Use Cases
- Smooth animations synchronized with gestures
- Real-time user input handling
- Complex gesture recognition
- Performance-critical UI updates

#### Implementation Example
```javascript
const SmoothScrollAnimation = () => {
  const handleScroll = (event) => {
    'main thread'; // Required directive
    
    // Get scroll position
    const scrollY = event.detail.scrollTop;
    
    // Update animation immediately
    const element = lynx.querySelector('#animated-element');
    element.setStyleProperty('transform', `translateY(${scrollY * 0.5}px)`);
  };

  return (
    <scroll-view main-thread:bindscroll={handleScroll}>
      <view id="animated-element" style="height:200px;background:blue;">
        Parallax element
      </view>
      <view style="height:1000px;">
        Long content for scrolling
      </view>
    </scroll-view>
  );
};
```

### Custom Native Components

Extend Lynx with platform-specific functionality through custom native elements.

#### Creating Custom Elements

**iOS Implementation** (Objective-C):
```objc
// LynxCustomButton.h
#import <Lynx/LynxUI.h>

@interface LynxCustomButton : LynxUI <UIButton *>
@end

// LynxCustomButton.m
#import "LynxCustomButton.h"

@implementation LynxCustomButton

LYNX_LAZY_REGISTER_UI("custom-button")

- (UIButton *)createView {
    UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem];
    [button setTitle:@"Custom Button" forState:UIControlStateNormal];
    return button;
}

@end
```

**Android Implementation** (Java):
```java
// LynxCustomButton.java
public class LynxCustomButton extends UIBase<Button> {
    
    @Override
    protected Button createView() {
        Button button = new Button(getContext());
        button.setText("Custom Button");
        return button;
    }
    
    static {
        LynxUIComponentRegistry.registerUIBase("custom-button", LynxCustomButton.class);
    }
}
```

**Usage in React**:
```javascript
<custom-button 
  bindtap={handleButtonPress}
  style="width:200px;height:50px;"
>
  Custom Native Button
</custom-button>
```

### Native Modules

Integrate platform-specific APIs through native modules.

#### Interface Declaration
```typescript
// typing.d.ts
interface LocalStorage {
  setItem(key: string, value: string): Promise<void>;
  getItem(key: string): Promise<string | null>;
  removeItem(key: string): Promise<void>;
}

declare module '@lynx/lynx' {
  interface LynxModules {
    LocalStorage: LocalStorage;
  }
}
```

#### iOS Implementation
```objc
// LynxLocalStorage.h
#import <Lynx/LynxModule.h>

@interface LynxLocalStorage : NSObject <LynxModule>
@end

// LynxLocalStorage.m
@implementation LynxLocalStorage

LYNX_EXPORT_MODULE(LocalStorage)

LYNX_EXPORT_METHOD(setItem:(NSString *)key value:(NSString *)value callback:(LynxCallback)callback) {
  [[NSUserDefaults standardUserDefaults] setObject:value forKey:key];
  callback(@[]);
}

LYNX_EXPORT_METHOD(getItem:(NSString *)key callback:(LynxCallback)callback) {
  NSString *value = [[NSUserDefaults standardUserDefaults] stringForKey:key];
  callback(@[value ?: [NSNull null]]);
}

@end
```

#### Usage in JavaScript
```javascript
import { lynx } from '@lynx/lynx';

const saveData = async () => {
  try {
    await lynx.modules.LocalStorage.setItem('user_name', 'John Doe');
    console.log('Data saved successfully');
  } catch (error) {
    console.error('Failed to save data:', error);
  }
};

const loadData = async () => {
  try {
    const name = await lynx.modules.LocalStorage.getItem('user_name');
    console.log('Loaded name:', name);
  } catch (error) {
    console.error('Failed to load data:', error);
  }
};
```

## Project Structure and Organization

### Recommended Project Structure
```
my-lynx-app/
├── src/
│   ├── components/
│   │   ├── common/
│   │   │   ├── Button/
│   │   │   ├── Input/
│   │   │   └── Layout/
│   │   └── screens/
│   │       ├── Home/
│   │       ├── Profile/
│   │       └── Settings/
│   ├── styles/
│   │   ├── global.css
│   │   ├── variables.css
│   │   └── components/
│   ├── assets/
│   │   ├── images/
│   │   ├── fonts/
│   │   └── icons/
│   ├── utils/
│   │   ├── helpers.ts
│   │   └── constants.ts
│   ├── types/
│   │   └── lynx.d.ts
│   └── App.tsx
├── lynx.config.ts
├── package.json
└── tsconfig.json
```

### Configuration Files

#### Lynx Configuration (`lynx.config.ts`)
```typescript
import { defineConfig } from '@lynx-js/rspeedy';
import { pluginReactLynx } from '@lynx-js/react-rsbuild-plugin';
import { pluginQRCode } from '@lynx-js/qrcode-rsbuild-plugin';

export default defineConfig({
  plugins: [
    pluginQRCode({
      schema(url) {
        return `${url}?fullscreen=true`;
      },
    }),
    pluginReactLynx(),
  ],
  environments: {
    lynx: {
      output: {
        target: 'node',
        format: 'cjs',
      },
    },
    web: {
      output: {
        assetPrefix: '/',
      },
    },
  },
  server: {
    host: '0.0.0.0',
    port: 3000,
  },
  dev: {
    hmr: true,
    liveReload: true,
  },
});
```

#### TypeScript Configuration
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "jsx": "react-jsx",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

## Building Complete Applications

### Navigation and Routing

Lynx applications can use React Router for navigation:

#### Setup
```bash
npm install react-router@6
```

#### Implementation
```javascript
import { BrowserRouter as Router, Routes, Route } from 'react-router';

const App = () => {
  return (
    <Router>
      <view style="flex:1;">
        <Routes>
          <Route path="/" element={<HomeScreen />} />
          <Route path="/profile" element={<ProfileScreen />} />
          <Route path="/settings" element={<SettingsScreen />} />
        </Routes>
      </view>
    </Router>
  );
};
```

#### Navigation Component
```javascript
import { useNavigate } from 'react-router';

const NavigationButton = ({ to, children }) => {
  const navigate = useNavigate();
  
  const handlePress = () => {
    navigate(to);
  };
  
  return (
    <view 
      bindtap={handlePress}
      style="padding:10px;background:#007AFF;borderRadius:5px;"
    >
      <text style="color:white;textAlign:center;">{children}</text>
    </view>
  );
};
```

### State Management

#### Built-in State (useState, useReducer)
```javascript
import { useState, useEffect } from '@lynx-js/react';

const Counter = () => {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  
  return (
    <view style="alignItems:center;padding:20px;">
      <text style="fontSize:24px;marginBottom:20px;">Count: {count}</text>
      <view style="flexDirection:row;gap:10px;">
        <view bindtap={decrement} style="padding:10px;background:red;">
          <text style="color:white;">-</text>
        </view>
        <view bindtap={increment} style="padding:10px;background:green;">
          <text style="color:white;">+</text>
        </view>
      </view>
    </view>
  );
};
```

#### External State Management (TanStack Query)
```bash
npm install @tanstack/react-query
```

```javascript
import { QueryClient, QueryClientProvider, useQuery } from '@tanstack/react-query';

const queryClient = new QueryClient();

const UserProfile = () => {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user'],
    queryFn: () => fetch('/api/user').then(res => res.json()),
  });
  
  if (isLoading) {
    return <text>Loading...</text>;
  }
  
  if (error) {
    return <text>Error loading user data</text>;
  }
  
  return (
    <view style="padding:20px;">
      <text style="fontSize:20px;fontWeight:bold;">{user.name}</text>
      <text style="color:gray;">{user.email}</text>
    </view>
  );
};

const App = () => {
  return (
    <QueryClientProvider client={queryClient}>
      <view style="flex:1;">
        <UserProfile />
      </view>
    </QueryClientProvider>
  );
};
```

### API Integration and Data Fetching

#### Fetch API
```javascript
const useApiData = (endpoint) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(endpoint);
        if (!response.ok) throw new Error('Network error');
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [endpoint]);
  
  return { data, loading, error };
};

// Usage
const ProductList = () => {
  const { data: products, loading, error } = useApiData('/api/products');
  
  if (loading) {
    return (
      <view style="flex:1;justifyContent:center;alignItems:center;">
        <text>Loading products...</text>
      </view>
    );
  }
  
  return (
    <list 
      list-type="single" 
      span-count={1}
      style="flex:1;"
    >
      {products?.map((product, index) => (
        <list-item key={product.id} item-key={`product-${index}`}>
          <ProductCard product={product} />
        </list-item>
      ))}
    </list>
  );
};
```

### Form Handling and Input

#### Custom Input Component
```javascript
const TextInput = ({ value, onChangeText, placeholder, style }) => {
  return (
    <view style={{
      borderWidth: 1,
      borderColor: '#ccc',
      borderRadius: 5,
      padding: 10,
      ...style
    }}>
      <text 
        style={{
          fontSize: 16,
          color: value ? '#000' : '#999'
        }}
        bindtap={() => {
          // Handle focus/input logic
          // This would typically involve native input handling
        }}
      >
        {value || placeholder}
      </text>
    </view>
  );
};

// Form Example
const LoginForm = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = async () => {
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (response.ok) {
        // Handle success
        console.log('Login successful');
      }
    } catch (error) {
      console.error('Login failed:', error);
    }
  };
  
  return (
    <view style="padding:20px;">
      <TextInput 
        value={email}
        onChangeText={setEmail}
        placeholder="Email"
        style="marginBottom:15px;"
      />
      <TextInput 
        value={password}
        onChangeText={setPassword}
        placeholder="Password"
        style="marginBottom:20px;"
      />
      <view 
        bindtap={handleSubmit}
        style="padding:15px;background:#007AFF;borderRadius:5px;"
      >
        <text style="color:white;textAlign:center;fontWeight:bold;">
          Login
        </text>
      </view>
    </view>
  );
};
```

## Building and Deployment

### Development vs Production Builds

#### Development Build
```bash
npm run dev
```
- Hot reloading enabled
- Debug information included
- Faster build times
- Source maps available

#### Production Build
```bash
npm run build
```
- Optimized and minified
- Debug information removed
- Smaller bundle size
- Performance optimized

### Multi-Environment Configuration

```typescript
// lynx.config.ts
import { defineConfig } from '@lynx-js/rspeedy';

export default defineConfig({
  environments: {
    // Lynx (mobile) build
    lynx: {
      output: {
        target: 'node',
        format: 'cjs',
        distPath: {
          root: 'dist/lynx',
          js: 'js',
          css: 'css',
        },
      },
      performance: {
        chunkSplit: {
          strategy: 'split-by-size',
          minSize: 20000,
          maxSize: 200000,
        },
      },
    },
    
    // Web build  
    web: {
      output: {
        target: 'web',
        distPath: {
          root: 'dist/web',
        },
        assetPrefix: process.env.NODE_ENV === 'production' 
          ? 'https://cdn.example.com/' 
          : '/',
      },
      html: {
        template: './public/index.html',
      },
    },
  },
});
```

### Integration with Existing Apps

#### iOS Integration

**1. Install Lynx SDK via CocoaPods**:
```ruby
# Podfile
pod 'LynxSDK'
```

**2. Initialize Lynx in AppDelegate**:
```objc
// AppDelegate.m
#import <LynxSDK/LynxSDK.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    [LynxEngine setupLynxEnvironment];
    return YES;
}

@end
```

**3. Create Lynx View Controller**:
```objc
// LynxViewController.m
#import <LynxSDK/LynxViewController.h>

@interface MyLynxViewController : LynxViewController
@end

@implementation MyLynxViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    // Load your Lynx app bundle
    [self loadLynxAppWithBundleURL:@"https://your-server.com/app.bundle"];
}

@end
```

#### Android Integration

**1. Add Lynx dependency**:
```gradle
// build.gradle (app level)
implementation 'com.lynx:lynx-sdk:3.x.x'
```

**2. Initialize in Application class**:
```java
// MainApplication.java
import com.lynx.LynxApplication;
import com.lynx.LynxEngine;

public class MainApplication extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        LynxEngine.setupLynxEnvironment(this);
    }
}
```

**3. Create Lynx Activity**:
```java
// LynxActivity.java
import com.lynx.LynxActivity;

public class MyLynxActivity extends LynxActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // Load your Lynx app bundle
        loadLynxApp("https://your-server.com/app.bundle");
    }
}
```

### Performance Optimization

#### Bundle Optimization
```typescript
// lynx.config.ts
export default defineConfig({
  performance: {
    // Code splitting
    chunkSplit: {
      strategy: 'split-by-size',
      minSize: 20000,
      maxSize: 200000,
    },
    
    // Bundle analysis
    bundleAnalyzer: process.env.ANALYZE === 'true',
    
    // Asset optimization
    printFileSize: true,
  },
  
  // Build cache for faster builds
  buildCache: {
    buildDependencies: ['package.json', 'lynx.config.ts'],
  },
});
```

#### Image Optimization
```javascript
// Import optimized images
import heroImage from '../assets/hero.png';
import thumbnailImage from '../assets/thumbnail.jpg';

const ImageGallery = () => {
  return (
    <view>
      <image 
        src={heroImage} 
        style="width:100%;aspectRatio:16/9;"
        auto-size
      />
      <image 
        src={thumbnailImage}
        style="width:100px;height:100px;"
        auto-size
      />
    </view>
  );
};
```

## Best Practices and Patterns

### Component Architecture

#### Compound Components Pattern
```javascript
const Card = ({ children, ...props }) => {
  return (
    <view 
      style={{
        background: 'white',
        borderRadius: 8,
        padding: 16,
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        ...props.style
      }}
    >
      {children}
    </view>
  );
};

const CardHeader = ({ children, ...props }) => {
  return (
    <view style={{ marginBottom: 12, ...props.style }}>
      {children}
    </view>
  );
};

const CardTitle = ({ children, ...props }) => {
  return (
    <text style={{ 
      fontSize: 18, 
      fontWeight: 'bold',
      ...props.style 
    }}>
      {children}
    </text>
  );
};

const CardContent = ({ children, ...props }) => {
  return (
    <view style={props.style}>
      {children}
    </view>
  );
};

// Attach sub-components
Card.Header = CardHeader;
Card.Title = CardTitle;
Card.Content = CardContent;

// Usage
const ProductCard = ({ product }) => {
  return (
    <Card>
      <Card.Header>
        <Card.Title>{product.name}</Card.Title>
      </Card.Header>
      <Card.Content>
        <image src={product.image} style="width:100%;height:200px;" />
        <text>{product.description}</text>
      </Card.Content>
    </Card>
  );
};
```

#### Custom Hooks Pattern
```javascript
// useAsyncData.js
const useAsyncData = (fetchFn, deps = []) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let mounted = true;
    
    const loadData = async () => {
      try {
        setLoading(true);
        setError(null);
        const result = await fetchFn();
        if (mounted) {
          setData(result);
        }
      } catch (err) {
        if (mounted) {
          setError(err);
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };
    
    loadData();
    
    return () => {
      mounted = false;
    };
  }, deps);
  
  return { data, loading, error, refetch: () => loadData() };
};

// Usage
const UserProfile = ({ userId }) => {
  const { data: user, loading, error } = useAsyncData(
    () => fetch(`/api/users/${userId}`).then(res => res.json()),
    [userId]
  );
  
  if (loading) return <text>Loading...</text>;
  if (error) return <text>Error: {error.message}</text>;
  
  return (
    <view>
      <text>{user.name}</text>
      <text>{user.email}</text>
    </view>
  );
};
```

### Performance Patterns

#### Virtualized Lists for Large Data
```javascript
const LargeDataList = ({ items }) => {
  const calculateItemHeight = (item) => {
    // Calculate estimated height based on content
    return item.description.length > 100 ? 120 : 80;
  };
  
  return (
    <list
      list-type="single"
      span-count={1}
      preload-buffer-count={10} // Preload items for smoother scrolling
      scroll-event-throttle={100} // Throttle scroll events
    >
      {items.map((item, index) => (
        <list-item
          key={item.id}
          item-key={`item-${item.id}`}
          estimated-main-axis-size-px={calculateItemHeight(item)}
        >
          <ItemComponent item={item} />
        </list-item>
      ))}
    </list>
  );
};
```

#### Memory Management
```javascript
const ImageGrid = ({ images }) => {
  const [loadedImages, setLoadedImages] = useState(new Set());
  
  const handleImageLoad = (imageId) => {
    setLoadedImages(prev => new Set([...prev, imageId]));
  };
  
  // Clean up loaded images when component unmounts
  useEffect(() => {
    return () => {
      setLoadedImages(new Set());
    };
  }, []);
  
  return (
    <list list-type="waterfall" column-count={2}>
      {images.map((image, index) => (
        <list-item key={image.id} item-key={`img-${index}`}>
          <view>
            {loadedImages.has(image.id) ? (
              <image 
                src={image.url} 
                style="width:100%;aspectRatio:1;"
                auto-size
              />
            ) : (
              <view style="width:100%;aspectRatio:1;background:#f0f0f0;">
                <text style="textAlign:center;marginTop:50%;">Loading...</text>
              </view>
            )}
          </view>
        </list-item>
      ))}
    </list>
  );
};
```

### Error Handling and Resilience

#### Error Boundaries
```javascript
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <view style="padding:20px;alignItems:center;">
          <text style="fontSize:18;color:red;marginBottom:10px;">
            Something went wrong
          </text>
          <text style="color:gray;textAlign:center;">
            {this.state.error?.message || 'An unexpected error occurred'}
          </text>
          <view 
            bindtap={() => this.setState({ hasError: false, error: null })}
            style="marginTop:20px;padding:10px;background:blue;borderRadius:5px;"
          >
            <text style="color:white;">Try Again</text>
          </view>
        </view>
      );
    }
    
    return this.props.children;
  }
}

// Usage
const App = () => {
  return (
    <ErrorBoundary>
      <MainContent />
    </ErrorBoundary>
  );
};
```

## Common Issues and Solutions

### Platform-Specific Considerations

#### Image Loading Issues
**Problem**: Images not displaying in production builds
**Solution**: Ensure proper asset configuration and imports

```typescript
// lynx.config.ts
export default defineConfig({
  environments: {
    lynx: {
      output: {
        assetPrefix: './', // Relative path for mobile assets
      },
    },
  },
});
```

```javascript
// Import images properly
import logo from '../assets/logo.png';

const Header = () => {
  return (
    <view>
      <image src={logo} style="width:100px;height:50px;" auto-size />
    </view>
  );
};
```

#### Event Type Issues in MTS
**Problem**: Missing main-thread event types causing TypeScript errors
**Solution**: Extend type definitions or use type assertions

```typescript
// types/lynx.d.ts
declare module '@lynx-js/react' {
  interface ViewProps {
    'main-thread:bindscroll'?: (event: any) => void;
    'main-thread:bindtap'?: (event: any) => void;
    'main-thread:bindlayoutchange'?: (event: any) => void;
  }
}
```

#### Windows Development Issues
**Problem**: Network connection issues on Windows
**Solution**: Configure server host explicitly

```typescript
// lynx.config.ts
export default defineConfig({
  server: {
    host: '0.0.0.0', // Listen on all interfaces
    port: 3000,
  },
});
```

### Performance Optimization

#### Large List Performance
```javascript
const OptimizedList = ({ data }) => {
  // Use keys that don't change to avoid unnecessary re-renders
  const stableKeyExtractor = useCallback((item, index) => {
    return item.id || `item-${index}`;
  }, []);
  
  return (
    <list
      list-type="single"
      span-count={1}
      // Optimize for performance
      preload-buffer-count={5}
      scroll-event-throttle={200}
      enable-nested-scroll={false} // If not needed
    >
      {data.map((item, index) => (
        <list-item
          key={stableKeyExtractor(item, index)}
          item-key={stableKeyExtractor(item, index)}
          reuse-identifier={item.type} // Group similar items for reuse
        >
          <ItemRenderer item={item} />
        </list-item>
      ))}
    </list>
  );
};
```

## Ecosystem and Community

### Popular Libraries and Tools

#### Styling
- **Tailwind CSS**: Utility-first CSS framework
- **Styled Components**: CSS-in-JS styling
- **Emotion**: Performant and flexible CSS-in-JS library

#### State Management
- **TanStack Query**: Data fetching and caching
- **Zustand**: Lightweight state management
- **Valtio**: Proxy-based state management

#### Utilities
- **React Router**: Navigation and routing
- **React Hook Form**: Form handling
- **Date-fns**: Date manipulation utilities

### Learning Resources

#### Official Documentation
- [Lynx Official Website](https://lynxjs.org)
- [ReactLynx Guide](https://lynxjs.org/react/introduction.html)
- [API Reference](https://lynxjs.org/api/)

#### Community Tutorials
- Step-by-step tutorials on Dev.to
- YouTube video courses
- GitHub example repositories

#### Example Projects
- Gallery application tutorial
- E-commerce app examples  
- Game development with Lynx

## Conclusion

Lynx represents a significant advancement in cross-platform development, offering web developers a path to native mobile app development without sacrificing performance or familiar development patterns. Its dual-threaded architecture, comprehensive CSS support, and React compatibility make it an compelling alternative to existing frameworks.

Key advantages of Lynx include:

- **Performance**: Native-level performance through dual-threaded architecture
- **Familiarity**: Leverages existing web development skills
- **Flexibility**: Framework-agnostic design with strong React support
- **Productivity**: Single codebase for multiple platforms
- **Extensibility**: Custom native components and modules

While Lynx is still evolving, with some component libraries and advanced features still in development, it provides a solid foundation for building high-quality cross-platform applications. As ByteDance continues to open-source additional components and tools, Lynx is positioned to become a major player in the cross-platform development ecosystem.

For web developers looking to expand into mobile development, or native developers seeking more efficient cross-platform solutions, Lynx offers a compelling combination of performance, familiarity, and productivity that makes it worth serious consideration for new projects.